# **Определение дерева, дерева с корнем. Высота дерева, родительские, дочерние узлы, листья. Количество ребер.**

**Дерево** - структура данных, представляющая набор вершин (узлов), соединенных ребрами.

- Узлы содержат данные и некоторые указатели на *дочерние узлы*.
- *Родительский узел* - который имеет дочерние узлы.
- Каждый узел (кроме корня) имеет ровно одного родителя. Узлы без потомков называются *листьями*. 
- Самый "верхний" узел дерева (не имеющий родительских) называется *корнем (root)*.
- *Высота* дерева - длина самого длинного пути от корня до листа (число ребер между нимиб например у дерева только из корня высота 0).
- *Количество ребер* в дереве всегда равно количеству узлов -1 (условно можно привязать к каждому узлу единственное ребро, соединяющее его с родителем. У корня такого нет -> N-1).

---

# **Обходы в глубину (Depth-First Search, DFS). Pre-order, post-order и in-order для бинарных деревьев.**

**Бинарное дерево** - в котором у каждого из родителей не больше 2 дочерних узлов.

**Обход в глубину** предполагает движение от корня к листьям, проходя каждую ветвь до конца перед переходом к следующей.

**Типы** (предполагают рекурсивный обход левой и правой веток для каждой вершины):

- pre-oder
- post-oder
- in-oder

---
### **Pre-oder**

*сначала вывод родителя, потом прохождение по ветвям*

псевдокод python:
```python
def foreach(root):
    if root == None:     # дошли до листьев
        return
    print(root.value)    # значение родительского узла
    foreach(root.left)   # рекурсия
    foreach(root.right)
```

---
### **Post-oder**

*сначала прохождение по ветвямб потом вывод родителя*

псевдокод python:
```python
def foreach(root):
    if root == None:
        return
    foreach(root.left)
    foreach(root.right)
    print(root.value)
```

---
### **In-oder**

*вывод родителя между ветвями*

псевдокод python:
```python
def foreach(root):
    if root == None:
        return
    foreach(root.left)
    print(root.value)
    foreach(root.right)
```
> Это самый приятный вариант для дерева поиска, т.к. выводит ключи вершин по возрастанию.

---
## **Обход в ширину (Breadth-First Search, BFS)**

**Обход в ширину** предполагает посещение всех узлов по уровням, начиная с корня (внутри уровня обход слева направо).
(аналогия: сначала дедушка, потом все родители, потом все дети, потом все внуки и т.п.)