# **Дерево поиска (Binary Search Tree, BST).**

**Бинарное дерево поиска** - бинарное дерево, для которого выполняются дополнительные условия:

- данные (data) обладают ключом (key), на котором определены операции сравнения. В конкретных реализациях это может быть пара (key, value) — (ключ, значение).
- все ключи в левом поддереве меньше ключа родителя
- все ключи в правом поддереве больше ключа родителя
- оба поддерева также являются бинарными поддеревьями поиска

> (рассматриваем вариант с отсутствием равных элементов)

**Возможные операции:**

- вставка ключа
- поиск ключа
- удаление ключа

---

# **Поиск ключа, вставка, удаление.**

### **Поиск ключа**

- начинаем с корня
- если дерево пусто (дошли до листа), сообщаем, что ключ не найден и останавливаемся
- если ключ равен текущему узлу, возвращаем его
- если ключ меньше ключа текущего узла, рекурсивно ищем его в левом поддереве
- если ключ больше --//-- в правом поддереве

### **Вставка**

- находим место до вставки (лист, к которому и в какую ветку присоединить ключ) по правилам поиска
- создаем новый узел в найденном месте

### **Удаление ключа**

- если узел - лист, просто удаляем его
- если у узла только одно дочернее поддерево, заменяем удаляемый узел на соответствующий дочерний
- если у узла два дочерних поддерева, находим максимальный узел левого поддерева или минимальный узел правого поддерева, заменяем удаляемый узел на этот, найденный узел из поддерева удаляем рекурсивно (у него могло быть правое дочернее поддерево)

> пояснение: все ключи в левом поддереве меньше родителя -> меньше всех ключей в правом поддереве. самый правый ключ в левом поддереве больше всех остальных в нем -> можем вставить его вместо родителя, не нарушая правил

---
# **Необходимость балансировки. Три типа самобалансирующихся деревьев.**

Сложность поиска ключа в бинарном дереве поиска - **О(h)**, где h - высота дерева. Поэтому более эффективны с точки зрения выполнения операций деревья с *балансировкой*, направленной на приближение размеров левых и правых поддеревьев у каждого родителя, а вследствие уменьшение общей h -> сложность приходит к **О(log n)**.

**Самобалансирующиеся деревья** - деревья, которые автоматически поддерживают свою сбалансированность после операций вставки и удаления.

**Основные типы**:

- **_AVL-дерево_** (разница высот левого и правого поддеревьев не превышает 1)
- **_красно-черное дерево_** (балансируется количеством черных узлов и правилом отсутствия красных потомков у красных родителей)
- **_декартово дерево_** (*treap* - от слов tree, heap) - гибридная структура данных со свойствами бинарного дерева и бинарной кучи (балансируется за счет случайного выбора *приоритетов*)
- *Splay-дерево* (splay - разворот) (перемещает недавно использованные элементы ближе к корню -> часто применяемые элементы находятся быстрее, но балансировка нестрогая)

